---
counts:
    characters_real: 5467
    characters_total: 6701
    file: ./posts/tech/how-charming/_posts/2016-12-15-part-2.md
    paragraphs: 40
    type: jekyll
    words: 1145
layout: serial-post
previous_in_category:
    title: How Charming - Part 1
    url: /posts/tech/how-charming/2016/12/13/part-1
title: How Charming - Part 2
---

*In the previous part, we started to nail down what it is that we're going to do to try and accomplish our task. We're going tow rite a charm - a package that represents a way to deploy a piece of software repeatably to the cloud - to do all that's needed to host a WSGI app. It will be able to talk to several different services and use any WSGI server. For more background, [check that post out first](/posts/tech/how-charming/2016/12/13/part-1)!*

"Hey! I think I have deployment all figured out for Honeycomb!" I blurted out in the Guild chat, sharing the link to the previous post.

Blank stares, then finally, "You wrote about the furry website you're building for work[^disclaimer]..?"

![It's true](/assets/tech/how-charming/part-2-furries.jpg){: style="max-width: 150px; float: left; margin: 0 1em 1em 0;" }

Point. But hey, furries make the internet go.[^furries-tech]

Anyhow, I digress. The goal of Honeycomb is not to be a furry website but a writing one, and besides, none of the guild really cared about the DevOps side of the site. That's something for me to worry about.  And as a developer with a fascination with the Ops side of things, I *do* care about deployment strategies.

Guild chat aside, Juju is a delightful step in making things much easier for us DevOpsy critters, because it allows us to write general and repeatable solutions that can be used within a ecosystem of other solutions to accomplish a specific goal. In our case, we want to be able to deploy any WSGI compliant application that can connect to a variety of other services and be hosted in the cloud.

These solutions, charms, are what we'll need to have to get our stack up and running, so let's get started in making our `wsgi-app` charm.

-----

### Bootstrapping the charm

As Juju is a Canonical offering (and I'm a Canonical employee), I'll be working in Ubuntu. Once you've got your system up and running with Ubuntu Xenial or later, installation of juju and the tools we need is fairly easy:

```shell
sudo apt install juju lxd charm-tools
```

This will install just about everything we need: we'll get juju itself, of course, as well as LXD, which is used for local and development environments, and `charm-tools`, which contains a few applications we'll be using for creating, building, and testing our charm.

Getting our charm set up after this point is fairly easy, but it does require deciding on how you're going to work with your charm. I have a work directory in which I keep all of my projects, and when developing a charm, it's often easiest to have all of your charm related work in its own directory structure. With that in mind, I'm going to set up the following directory structure for working with `wsgi-app`:

```
~
└── work
    └── charms
        ├── builds
        ├── interfaces
        └── layers
```

We'll get into what interfaces and layers are in just a second, but for now, that's the basic structure that one needs to get started with building a charm. This is because the various charm tools expect to find a certain structure when they do their work.  This is all controlled through environment variables:

```shell
export JUJU_REPOSITORY=$HOME/work/charms
export LAYER_PATH=$JUJU_REPOSITORY/layers
export INTERFACE_PATH=$JUJU_REPOSITORY/interfaces

# or, in fish:

set -x JUJU_REPOSITORY ~/work/charms
set -x LAYER_PATH $JUJU_REPOSITORY/layers
set -x INTERFACE_PATH $JUJU_REPOSITORY/interfaces

# then:

mkdir -p $LAYER_PATH $INTERFACE_PATH
```

Now that we've got our basic directory structure in place, we can start to actually build out our charm. Thankfully, the charm tools give us a way to do so with a simple command:

```shell
# First, get to the layer directory, where we'll be working on our charm
makyo@corrin:~$ cd $LAYER_PATH
makyo@corrin:~/work/charms/layers$ charm create wsgi-app
INFO: Using default charm template (reactive-python). To select a different template, use the -t option.
INFO: Generating charm for wsgi-app in ./wsgi-app
INFO: No wsgi-app in apt cache; creating an empty charm instead.
Cloning into '/tmp/tmp52ugnq'...
remote: Counting objects: 27, done.
remote: Total 27 (delta 0), reused 0 (delta 0), pack-reused 27
Unpacking objects: 100% (27/27), done.
Checking connectivity... done.
```

`charm create` will do a few things, as shown above, but in short, it will create a `wsgi-app` directory for us, and populate it with a basic template upon which we'll build our charm.  This winds up giving you a directory like so:

```
/home/makyo/work/charms/layers/wsgi-app
├── config.yaml
├── icon.svg
├── layer.yaml
├── metadata.yaml
├── reactive
│   └── wsgi_app.py
├── README.ex
└── tests
    ├── 00-setup
    └── 10-deploy
```

There's a lot going on here, so it's time we take a step back and talk about what goes into building a charm, and the two important concepts to learn about: hooks and layers.

-----

### Hooks

Charms, as deployment solutions, are fundamentally reactive. When you deploy a charm, it goes through several stages, and at each stage, the charm has a chance to react to what's going on during the deployment process. The same with other things going on around the charm: when configuration values are changed, or a relation (a means of communication between two services) is added or removed or changed, the charm can react to that as well.

As with many other reactive frameworks, we call these sorts of reactions 'hooks'. For example, when you first deploy a charm with juju, the charm receives several hooks from juju once the machine it is to be deployed on is up and running. It will start with the `install` hook, which is usually when the hook has a chance to install all of its software. After that, it will receive the `config-changed` hook, which is when the charm will learn about all of the configuration options that the user has specified and can react accordingly. Finally, it will receive a `start` hook, which is when any long-running processes such as servers will be started. `stop` is another hook, as well, of course, wherein one might back-up any charm data.

{% include tech/how-charming/part-2-hooks.svg %}

In reality, most of the work that is done within the charm happens during the `config-changed` hook, while `install` is used only for installing ancillary software and `start` is often just ignored. This is because that is the hook which will always occur after startup and any configuration changes. This way, you can just restart all tasks during `config-changed`, as this will cause config files to be reloaded and so on.

We'll get more into relations in a later part, but for now, it's enough to understand that relations are, primarily, ways in which one service can expose information to another. They're not, contrary to their names or how they appear in visualizations, means or representations of communication between services. Rather, one can think of them as the juju controller allowing the two services to acknowledge that they exist to each other. In our instance, this will mean that, when a relation is created between `wsgi-app` and PostGres,

-----

### Layers

-----

### `wsgi-app` as a layer

-----

[^disclaimer]: As always, views are my own, not my employer's.

[^furries-tech]: Seriously. After students (54%), nearly 10% of furries are employed in the tech industry, making it the most common occupation within the subculture. (The Furry Poll, conducted March-December 2015, *n=11831*)
